# Auto generated by LangBot Plugin SDK.
# Please refer to https://docs.langbot.app/en/plugin/dev/tutor.html for more details.
from __future__ import annotations

from langbot_plugin.api.definition.plugin import BasePlugin

import json, itertools, random, re
from pathlib import Path

class KCDDiceGame(BasePlugin):

    def __init__(self):
        super().__init__()

    async def initialize(self) -> None:
        self.status = False
        self.player = ["",""]
        self.score = [0, 0]
        self.turn = 0
        self.dice_lake = []
        self.dice_num = 6
        self.count = 0
        self.temp_score = 0
        self.target_score = 1500
        self.mode = 0 #游戏模式，0为无徽章模式，1为徽章模式
        self.badge_list = [["金制换点徽章", 1], ["金制幸运徽章", 1], ["金制力量徽章", 3], ["金制君主徽章", 0], ["金制先行徽章", 0], ["金制镜像徽章", 3], ["金制重投徽章", 3], ["金制军阀徽章", 1]]
        self.badge_counts = [0, 0]
        self.plugin_path = Path(__file__).parent
        try:
            with open(self.plugin_path / "badge.json", 'r', encoding='utf-8') as f:
                self.player_badges = json.load(f)
        except FileNotFoundError:
            with open(self.plugin_path / "badge.json", 'w', encoding='utf-8') as f:
                self.player_badges = {}
                f.write(json.dumps(self.player_badges))
        pass
        self.wait = -1 #徽章后续操作等待标志，值为等待中的徽章id，-1意味着没有等待
        self.archlord = False #判断是否触发了金制君主徽章

    def save_badges(self):
        try:
            with open(self.plugin_path / "badge.json", 'w', encoding='utf-8') as f:
                json.dump(self.player_badges, f, ensure_ascii=False, indent=4)
        except Exception as e:
            print(f"保存徽章列表失败：{e}")
    
    def init_badges(self):
        for index, player in enumerate(self.player):
            self.badge_counts[index] = self.badge_list[self.player_badges[str(player)]][1]

    def badge_str(self):
        player_id = self.player[self.turn]
        return f"{player_id} 使用了{self.badge_list[self.player_badges[str(player_id)]][0]}，剩余使用次数为{self.badge_counts[self.turn]}次"

    def dice_calculate(self, dice_ids):
        dices = [0, 0, 0, 0, 0, 0]
        for item in dice_ids:
            dices[self.dice_lake[item - 1] - 1] += 1
        return dices
    
    def score_calculate(self, dices):
        #首先判断金制君主徽章
        if self.mode == 1:
            if dices[0] >= 3 and dices[0] < 6 and self.player_badges[str(self.player[self.turn])] == 3:
                dices[0] -= 3
                self.archlord = True
                return 3000 + self.score_calculate(dices)
        if all(x == 1 for x in dices): #存在1,2,3,4,5,6
            return 1500
        if all(x >= 1 for x in dices[:5]): #存在1,2,3,4,5
            dices = [x - y for x, y in zip(dices, [1, 1, 1, 1, 1, 0])]
            if dices == [0, 0, 0, 0, 0, 0]:
                return 500
            else:
                score_remains = self.score_calculate(dices)
                if score_remains != 0:
                    return 500 + score_remains
                else:
                    return 0
        if all(x >= 1 for x in dices[1:]): # 存在2,3,4,5,6
            dices = [x - y for x, y in zip(dices, [0, 1, 1, 1, 1, 1])]
            if dices == [0, 0, 0, 0, 0, 0]:
                return 750
            else:
                score_remains = self.score_calculate(dices)
                if score_remains != 0:
                    return 750 + score_remains
                else:
                    return 0
        score = 0
        score_rules = {
            1: (100, 1000),
            5: (50, 500),
            2: (0, 200),
            3: (0, 300),
            4: (0, 400),
            6: (0, 600),
        }

        for i, count in enumerate(dices):
            if count >= 1 and i + 1 in score_rules:
                if count <= 2:
                    score += score_rules[i + 1][0] * count
                else:
                    score += score_rules[i + 1][1] * (2 ** (count - 3))
                dices[i] = 0
                if dices == [0, 0, 0, 0, 0, 0]:
                    return score
                else:
                    score_remains = self.score_calculate(dices)
                    if score_remains != 0:
                        return score + score_remains
                    else:
                        return 0
        return 0
    def score_check(self, dice_lake):
        dices = [0, 0, 0, 0, 0, 0]
        for i in range(1, 6):
            for dice_combines in itertools.combinations(dice_lake, i):
                dices = [0, 0, 0, 0, 0, 0]
                for item in dice_combines:
                    dices[item - 1] += 1
                if self.score_calculate(dices) != 0:
                    return True
        return False
    def build_dice_str(self):
        str = f"第{self.count}次投骰！结果：\n"
        for index, item in enumerate(self.dice_lake):
            str += f"{index + 1}. {item}点\n"
        str += f"\n本回合积分：{self.temp_score} 总积分：{self.score[self.turn]}"
        return str
    def roll_dice(self, dice_ids="", reroll=False):
        if reroll and re.match(fr"^(?!.*(.).*\1)[1-{self.dice_num}]{{1,{self.dice_num}}}$", dice_ids):
            for dice_id in dice_ids:
                self.dice_lake[int(dice_id) - 1] = random.randint(1, 6)
        else:
            self.count += 1
            self.dice_lake = []
            for i in range(self.dice_num):
                self.dice_lake.append(random.randint(1, 6))
        self.wait = -1
        return self.score_check(self.dice_lake)
    def turn_change(self):
        self.count = 0
        self.turn = 1 - self.turn
        self.dice_num = 6
        self.temp_score = 0
        self.wait = -1
        self.archlord = False
    def init_game(self):
        self.status = False
        self.player = ["",""]
        self.score = [0, 0]
        self.turn = 0
        self.dice_lake = []
        self.dice_num = 6
        self.count = 0
        self.temp_score = 0
        self.target_score = 1500
        self.wait = -1
        self.mode = 0
        self.badge_counts = [0, 0]
        self.archlord = False
    def roll_str(self):
        return f"\n\n现在是 {self.player[self.turn]} 的回合。\n请输入\"投骰\"或\"kcd roll\"进行本回合第一次投骰。"